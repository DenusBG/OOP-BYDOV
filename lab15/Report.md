Звіт з самостійної роботи №15: Аналіз SRP та OCP
Тема: Дослідження принципів SOLID у відкритих проєктах.

1. Обраний проєкт
Назва: Newtonsoft.Json (найпопулярніша бібліотека для роботи з JSON у .NET).

Посилання на GitHub: JamesNK/Newtonsoft.Json

2. Аналіз SRP (Single Responsibility Principle)
2.1. Приклади дотримання SRP
Клас: JsonTextReader

Відповідальність: Потокове читання тексту та ідентифікація JSON-токенів (об'єктів, масивів, значень).

Обґрунтування: Клас не займається десеріалізацією або логікою бізнесу. Його єдина задача — перетворити потік символів у зрозумілі структури JSON.

Клас: CamelCasePropertyNamesContractResolver

Відповідальність: Визначення правил іменування властивостей (перетворення назв у camelCase).

Обґрунтування: Він не знає, як записувати дані у файл, він лише відповідає за трансформацію рядків.

2.2. Приклад порушення SRP
Клас: JsonSerializer

Множинні відповідальності: Цей клас є «центром управління». Він одночасно керує:

Процесом серіалізації/десеріалізації.

Налаштуваннями обробки помилок.

Кешуванням контрактів типів.

Проблеми: Він став занадто великим ("God Object"), що робить будь-яку зміну в базовій логіці ризикованою для всього проєкту.

3. Аналіз OCP (Open/Closed Principle)
3.1. Приклади дотримання OCP
Механізм: JsonConverter

Опис: Newtonsoft.Json надає абстрактний клас JsonConverter.

Обґрунтування: Ви можете додати підтримку будь-якого нового складного типу даних, просто створивши власний клас-нащадок JsonConverter. При цьому код самої бібліотеки залишається незмінним. Система відкрита для розширення, але закрита для модифікації.

Фрагмент коду (приклад розширення):

C#

public class MyCustomConverter : JsonConverter
{
    public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
    {
        // Власна логіка запису без зміни ядра бібліотеки
    }
}
3.2. Приклад порушення OCP
Модуль: Внутрішні перевірки типів (PrimitiveTypeCode).

Проблема: У деяких внутрішніх методах використовуються великі блоки switch, які перевіряють типи даних (int, string, bool).

Наслідки: Якщо у платформі .NET з'явиться новий фундаментальний тип, розробникам Newtonsoft.Json доведеться вручну змінювати існуючий код бібліотеки, щоб додати новий case, що є ознакою порушення OCP.

4. Загальні висновки
Проєкт Newtonsoft.Json є чудовим прикладом застосування SOLID на практиці. Хоча центральні класи мають тенденцію до перетворення на "God Objects", основна гнучкість бібліотеки досягнута завдяки інтерфейсам та абстракціям, що дозволяє мільйонам розробників розширювати її функціонал без втручання в основний код.